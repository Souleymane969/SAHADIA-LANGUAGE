# ðŸ•Šï¸ SAHADIA LANGUAGE
# Soul Bridge â€“ AST to Python
# Official Implementation v1.1
#
# In memory of Sahadia.

from compiler.ast import *
from compiler.stdlib import SAHADIA_STDLIB


class SoulBridge:
    def __init__(self):
        self.lines = []
        self.indent = 0
        self.used_libraries = set()

    def generate(self, program: ProgramNode) -> str:
        self.lines.append("# Generated by SAHADIA C (SCL)")
        self.lines.append("")
        for stmt in program.statements:
            self.visit(stmt)
        return "\n".join(self.lines)

    def emit(self, line):
        self.lines.append("    " * self.indent + line)

    def visit(self, node):
        method = getattr(self, f"visit_{type(node).__name__}")
        method(node)

    # ============
    # STATEMENTS
    # ============

    def visit_SoulNode(self, node):
        self.emit(f"print({self.expr(node.message)})")

    def visit_SayNode(self, node):
        self.emit(f"print({self.expr(node.message)})")

    def visit_RememberNode(self, node):
        self.emit(f"{node.name} = {self.expr(node.value)}")

    def visit_AskNode(self, node):
        self.emit(f"{node.target} = input({self.expr(node.question)})")

    def visit_IfNode(self, node):
        self.emit(f"if {self.expr(node.condition)}:")
        self.indent += 1
        for stmt in node.then_body:
            self.visit(stmt)
        self.indent -= 1
        if node.else_body:
            self.emit("else:")
            self.indent += 1
            for stmt in node.else_body:
                self.visit(stmt)
            self.indent -= 1

    def visit_RepeatNode(self, node):
        self.emit(f"for _ in range({self.expr(node.times)}):")
        self.indent += 1
        for stmt in node.body:
            self.visit(stmt)
        self.indent -= 1

    def visit_UseNode(self, node):
        self.used_libraries.add(node.library_name)
        self.emit(f"# SAHADIA use {node.library_name}")

    # ============
    # EXPRESSIONS
    # ============

    def expr(self, node):
        if isinstance(node, NumberNode):
            return str(node.value)

        if isinstance(node, StringNode):
            return repr(node.value)

        if isinstance(node, IdentifierNode):
            return node.name

        if isinstance(node, BinaryExpressionNode):
            return f"({self.expr(node.left)} {self.map_op(node.operator)} {self.expr(node.right)})"

        if isinstance(node, FunctionCallNode):
            for lib in self.used_libraries:
                funcs = SAHADIA_STDLIB.get(lib, {})
                if node.name in funcs:
                    arg = self.expr(node.arguments[0])
                    return funcs[node.name](arg)
            raise Exception(f"Unknown function '{node.name}'")

        raise Exception(f"Unsupported expression {node}")

    def map_op(self, op):
        return {
            "plus": "+",
            "minus": "-",
            "fois": "*",
            "divided": "/",
            "power": "**",
            "above": ">",
            "greater": ">",
            "below": "<",
            "less": "<",
            "equal": "==",
            "same": "==",
            "not": "!=",
            "different": "!="
        }[op]
