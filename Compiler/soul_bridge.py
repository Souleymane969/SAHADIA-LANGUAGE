# ðŸ•Šï¸ SAHADIA LANGUAGE
# Soul Bridge â€“ AST to Python generator
# Official Implementation v1.0
#
# In memory of Sahadia.

from compiler.ast import (
    ProgramNode,
    SoulNode,
    SayNode,
    RememberNode,
    AskNode,
    IfNode,
    RepeatNode,
    NumberNode,
    StringNode,
    IdentifierNode,
    BinaryExpressionNode,
    UseNode,
    FunctionNode,
    ReturnNode
)


class SoulBridge:
    def __init__(self):
        self.indent_level = 0
        self.lines = []

    # -------------------------
    # ENTRY POINT
    # -------------------------
    def generate(self, program: ProgramNode) -> str:
        self.lines.append("# Generated by SAHADIA C (SCL)")
        self.lines.append("")
        for stmt in program.statements:
            self.visit(stmt)
        return "\n".join(self.lines)

    # -------------------------
    # VISITOR DISPATCH
    # -------------------------
    def visit(self, node):
        method_name = f"visit_{type(node).__name__}"
        visitor = getattr(self, method_name, self.generic_visit)
        visitor(node)

    def generic_visit(self, node):
        raise Exception(f"No visitor for {type(node).__name__}")

    # -------------------------
    # HELPERS
    # -------------------------
    def emit(self, line: str):
        self.lines.append("    " * self.indent_level + line)

    # -------------------------
    # STATEMENTS
    # -------------------------
    def visit_SoulNode(self, node: SoulNode):
        self.emit(f"print({self.expr(node.message)})")

    def visit_SayNode(self, node: SayNode):
        self.emit(f"print({self.expr(node.message)})")

    def visit_RememberNode(self, node: RememberNode):
        self.emit(f"{node.name} = {self.expr(node.value)}")

    def visit_AskNode(self, node: AskNode):
        self.emit(f"{node.target} = input({self.expr(node.question)})")

    def visit_IfNode(self, node: IfNode):
        self.emit(f"if {self.expr(node.condition)}:")
        self.indent_level += 1
        for stmt in node.then_body:
            self.visit(stmt)
        self.indent_level -= 1

        if node.else_body:
            self.emit("else:")
            self.indent_level += 1
            for stmt in node.else_body:
                self.visit(stmt)
            self.indent_level -= 1

    def visit_RepeatNode(self, node: RepeatNode):
        self.emit(f"for _ in range({self.expr(node.times)}):")
        self.indent_level += 1
        for stmt in node.body:
            self.visit(stmt)
        self.indent_level -= 1

    def visit_UseNode(self, node: UseNode):
        # Placeholder for future stdlib support
        self.emit(f"# use library: {node.library_name}")

    def visit_FunctionNode(self, node: FunctionNode):
        params = ", ".join(node.parameters)
        self.emit(f"def {node.name}({params}):")
        self.indent_level += 1
        for stmt in node.body:
            self.visit(stmt)
        self.indent_level -= 1

    def visit_ReturnNode(self, node: ReturnNode):
        self.emit(f"return {self.expr(node.value)}")

    # -------------------------
    # EXPRESSIONS
    # -------------------------
    def expr(self, node):
        if isinstance(node, NumberNode):
            return str(node.value)

        if isinstance(node, StringNode):
            return repr(node.value)

        if isinstance(node, IdentifierNode):
            return node.name

        if isinstance(node, BinaryExpressionNode):
            return f"({self.expr(node.left)} {self.map_operator(node.operator)} {self.expr(node.right)})"

        raise Exception(f"Unsupported expression {type(node).__name__}")

    def map_operator(self, op: str) -> str:
        return {
            "plus": "+",
            "minus": "-",
            "fois": "*",
            "divided": "/",
            "power": "**",
            "above": ">",
            "greater": ">",
            "below": "<",
            "less": "<",
            "equal": "==",
            "same": "==",
            "not": "!=",
            "different": "!="
        }.get(op, op)
